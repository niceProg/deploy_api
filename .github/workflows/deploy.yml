name: Deploy API

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: deploy-api-production
  cancel-in-progress: true

jobs:
  deploy:
    name: Deploy to server
    runs-on: ubuntu-latest
    timeout-minutes: 25
    env:
      DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
      DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
      DEPLOY_PORT: ${{ secrets.DEPLOY_PORT || '22' }}
      DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
      DEPLOY_BRANCH: ${{ vars.DEPLOY_BRANCH || 'main' }}
      SSH_PRIVATE_KEY: ${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}
      SSH_KEY_PASSPHRASE: ${{ secrets.DEPLOY_SSH_PASSPHRASE }}
      DEPLOY_HOST_KEY: ${{ secrets.DEPLOY_HOST_KEY }}
    steps:
      - name: Validate required deploy secrets
        shell: bash
        run: |
          set -euo pipefail
          for key in DEPLOY_HOST DEPLOY_USER DEPLOY_PATH SSH_PRIVATE_KEY; do
            if [ -z "${!key}" ]; then
              echo "::error::Missing required configuration: ${key}"
              exit 1
            fi
          done

      - name: Configure SSH client
        shell: bash
        run: |
          set -euo pipefail
          install -m 700 -d ~/.ssh
          printf '%s\n' "$SSH_PRIVATE_KEY" | sed 's/\r$//' > ~/.ssh/id_deploy
          chmod 600 ~/.ssh/id_deploy

          if grep -q "^PuTTY-User-Key-File-" ~/.ssh/id_deploy; then
            echo "::error::DEPLOY_SSH_PRIVATE_KEY is PuTTY .ppk format. Use OpenSSH private key content instead."
            exit 1
          fi

          key_encrypted=0
          if grep -qi "ENCRYPTED" ~/.ssh/id_deploy; then
            key_encrypted=1
          fi

          if [ "$key_encrypted" = "1" ] && [ -z "${SSH_KEY_PASSPHRASE:-}" ]; then
            echo "::error::Encrypted SSH key detected. Set secret DEPLOY_SSH_PASSPHRASE."
            exit 1
          fi

          if [ "$key_encrypted" = "1" ]; then
            # Remove accidental CRLF/trailing newline from copied secret values.
            PASSPHRASE_CLEAN="$(printf '%s' "$SSH_KEY_PASSPHRASE" | tr -d '\r')"
            PASSPHRASE_CLEAN="${PASSPHRASE_CLEAN%$'\n'}"
            if ! ssh-keygen -p -P "$PASSPHRASE_CLEAN" -N "" -f ~/.ssh/id_deploy >/dev/null 2>&1; then
              echo "::error::Cannot decrypt DEPLOY_SSH_PRIVATE_KEY. Check DEPLOY_SSH_PASSPHRASE and key pairing."
              exit 1
            fi
          fi

          if ! ssh-keygen -yf ~/.ssh/id_deploy >/dev/null 2>&1; then
            echo "::error::DEPLOY_SSH_PRIVATE_KEY is invalid or unreadable after processing."
            exit 1
          fi

          if [ -n "$DEPLOY_HOST_KEY" ]; then
            printf '%s\n' "$DEPLOY_HOST_KEY" >> ~/.ssh/known_hosts
          else
            ssh-keyscan -p "$DEPLOY_PORT" -H "$DEPLOY_HOST" >> ~/.ssh/known_hosts
          fi

      - name: Pull latest commit and run deployment script
        shell: bash
        run: |
          set -euo pipefail
          ssh -i ~/.ssh/id_deploy -p "$DEPLOY_PORT" -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes "$DEPLOY_USER@$DEPLOY_HOST" \
            "DEPLOY_PATH='$DEPLOY_PATH' DEPLOY_BRANCH='$DEPLOY_BRANCH' bash -s" <<'REMOTE'
          set -euo pipefail
          if ! command -v sudo >/dev/null 2>&1; then
            echo "::error::sudo is required on remote server but is not installed."
            exit 1
          fi
          if ! sudo -n true >/dev/null 2>&1; then
            echo "::error::sudo requires password. Configure passwordless sudo for DEPLOY_USER."
            exit 1
          fi

          cd "$DEPLOY_PATH"
          git_safe() {
            git -c safe.directory="$DEPLOY_PATH" "$@"
          }
          git_dir="$(git_safe rev-parse --git-dir)"
          if [ ! -w "$git_dir" ] || { [ -e "$git_dir/FETCH_HEAD" ] && [ ! -w "$git_dir/FETCH_HEAD" ]; }; then
            sudo chown -R "$(id -u):$(id -g)" "$DEPLOY_PATH"
          fi
          git_safe fetch origin "$DEPLOY_BRANCH"
          git_safe checkout "$DEPLOY_BRANCH"
          git_safe pull --ff-only origin "$DEPLOY_BRANCH"
          sudo chmod +x deploy_api.sh
          sudo ./deploy_api.sh
          REMOTE
